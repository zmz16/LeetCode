# 题目链接

https://leetcode.cn/problems/count-complete-tree-nodes/description/

## 一、普通二叉树

### 递归法

```cpp
// 自己写的
class Solution {
public:
    int traversal (TreeNode * node, int & count) {
        if (node == nullptr) {
            return 0;
        }
        count++;
        traversal(node->left, count);
        traversal(node->right, count);
        return count;
    }
    int countNodes(TreeNode* root) {
        int count = 0;
        return traversal(root, count);
    }
};

// 参考别人的
class Solution {
public:
    int getNodeNums (TreeNode * node) {
        if (node == nullptr) {
            return 0;
        }
        int leftNums = getNodeNums(node->left);
        int rightNums = getNodeNums(node->right);
        return leftNums + rightNums + 1;
    }
    int countNodes(TreeNode* root) {
        return getNodeNums(root);
    }
};

// 最终简化版本
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

### 迭代法

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        int result = 0;
        queue<TreeNode*> que;

        if (root) {
            que.push(root);
        }

        while ( ! que.empty()) {
            int size = que.size();

            while (size--) {
                TreeNode * node = que.front();
                que.pop();
                result++;

                if (node->left) {
                    que.push(node->left);
                }
                if (node->right) {
                    que.push(node->right);
                }
            }
        }
        return result;
    }
};
```

## 二、完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。**若最底层为第 h 层，则该层包含 `1~ 2^(h-1)` 个节点**。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 `2^树深度 - 1` 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int result = 0;
        TreeNode * leftNode = root->left;
        TreeNode * rightNode = root->right;
        int leftDepth = 0, rightDepth = 0;

        while (leftNode) {
            leftNode = leftNode->left;
            leftDepth++;
        }
        while (rightNode) {
            rightNode = rightNode->right;
            rightDepth++;
        }

        if (leftDepth == rightDepth) {
            result = (2 << leftDepth) - 1;
        }

        int leftCount = countNodes(root->left);
        int rightCount = countNodes(root->right);
        result = leftCount + rightCount + 1;
        return result;
    }
};
```