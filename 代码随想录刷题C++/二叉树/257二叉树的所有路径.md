# 题目链接

https://leetcode.cn/problems/binary-tree-paths/description/

## 递归

**前序遍历** + **回溯法**

```cpp
class Solution {
public:
    void traversal(TreeNode * curr, vector<int> & path, vector<string> & result) {
        path.push_back(curr->val);   // 中，中为什么写在这里，因为最后一个节点也要加入到path中 

        if (curr->left == nullptr && curr->right == nullptr) {   // 这才到了叶子节点
            string sPath;   // 转为题目要求的输出格式
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }

        if (curr->left) {
            traversal(curr->left, path, result);
            path.pop_back();   // 回溯，因为这里的引用传参，每次递归都会改变path的值，回溯是将层递归的节点弹出
        }
        if (curr->right) {
            traversal(curr->right, path, result);
            path.pop_back();
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        vector<string> result;
        if (root == nullptr) {
            return result;
        }
        traversal(root, path, result);
        return result;
    }
};
```