# 题目链接

https://leetcode.cn/problems/unique-paths/description/

## 深度优先搜索（超时了）

机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点，问题就可以转化为求二叉树叶子节点的个数。

```cpp
class Solution {
    int dfs(int i, int j, int m, int n) {
        if (i > m || j > n) {   // 越界了
            return 0;
        }
        if (i == m && j == n) {   // 找到一条路径
            return 1;
        }
        return dfs(i, j + 1, m, n) + dfs(i + 1, j, m, n);
    }
public:
    int uniquePaths(int m, int n) {
        return dfs(1, 1, m, n);
    }
};
```

## 动态规划

1. `dp[i][j]` ：表示从`（0，0）`出发，到`(i, j)` 有`dp[i][j]`条不同的路径。
2. `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`
3. 初始化
```
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```
4. 从左往右，从上往下
5. 举例推导数组

### 用二维数组存dp

时间复杂度：O(m × n)
空间复杂度：O(m × n)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        //将第0行和第0列都初始化为1，这些位置只有1条路径可达
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        // 遍历dp
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 用一维数组（滚动数组）存dp，优化空间

时间复杂度：O(m × n)
空间复杂度：O(n)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);  // 初始化为1
        // 遍历dp
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```

## 数论

无论怎么走，走到终点都需要 `m + n - 2` 步，`m - 1`步向下，`n - 1`步向右，那么这个问题可以转化为，给你`m + n - 2`个不同的数，随便取`m - 1`个数，有几种取法。

那么这就是一个**组合问题**了。

即求$C_{m + n - 2}^{m - 1}$的值。

**要注意分子的溢出问题**

时间复杂度：O(m)
空间复杂度：O(1)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long numerator = 1;   // 分子
        int denominator = m - 1;   // 分母
        int count = m - 1;
        int t = m + n - 2;
        while (count--) {
            numerator *= (t--);
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }
        }
        return numerator;
    }
};
```
