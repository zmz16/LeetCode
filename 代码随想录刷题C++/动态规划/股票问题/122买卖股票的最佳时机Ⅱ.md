# 题目链接

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/

## 贪心

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        for (int i = 1; i < prices.size(); i++) {
            if (prices[i] - prices[i - 1] > 0) {
                ans += prices[i] - prices[i - 1];
            }
        }
        return ans;
    }
};
```

## 动态规划

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2));   // 0：持有股票的最多现金，1：不持有股票的最多现金
        dp[0][0] = -prices[0];   // 持有股票的话最多现金为负，
        dp[0][1] = 0;   // 不持有股票现金为0

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);   // 与121题唯一不同的地方，因为可以多次买卖，所以当天买入的情况要加上前一天不持有的利润
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i][0]);   // 前一天不持有/当天卖出
        }
        return dp[prices.size() - 1][1];   // 最后最大值一定是不持有的状态，一直不持有的话是负数
    }
};
```

## 滚动数组

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(2));   // 0：持有股票的最多现金，1：不持有股票的最多现金
        dp[0][0] = -prices[0];   // 持有股票的话最多现金为负，
        dp[0][1] = 0;   // 不持有股票现金为0

        for (int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]);   // 与121题唯一不同的地方，因为可以多次买卖，所以当天买入的情况要加上前一天不持有的利润
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[i % 2][0]);   // 前一天不持有/当天卖出
        }
        return dp[(prices.size() - 1) % 2][1];   // 最后最大值一定是不持有的状态，一直不持有的话是负数
    }
};
```
