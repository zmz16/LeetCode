# 题目链接

https://leetcode.cn/problems/target-sum/description/

## 回溯算法

本题要如何使表达式结果为`target`，

既然为`target`，那么就一定有 `left组合 - right组合 = target`。

`left + right = sum`，而`sum`是固定的。`right = sum - left`

`left - (sum - left) = target` 推导出 `left = (target + sum)/2` 。

`target`是固定的，`sum`是固定的，`left`就可以求出来。

此时问题就是在集合`nums`中找出和为`left`的组合。

```cpp
class Solution {
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& nums, int new_target, int sum, int startIndex) {
        if (sum == new_target) {
            result.push_back(path);
        }

        for (int i = startIndex; i < nums.size() && sum <= new_target; i++) {
            sum += nums[i];
            path.push_back(nums[i]);
            backtracking(nums, new_target, sum, i + 1);
            path.pop_back();
            sum -= nums[i];
        }
    }

public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (target > sum) return 0;
        if ((target + sum) % 2 != 0) return 0;
        int new_target = (target + sum) / 2;   // 转变为组合总和问题

        path.clear();
        result.clear();
        sort(nums.begin(), nums.end());
        backtracking(nums, new_target, 0, 0);
        return result.size();
    }
};
```

## 动态规划（二维数组）

假设加法的总和为`x`，那么减法对应的总和就是`sum - x`。

所以我们要求的是 `x - (sum - x) = target`

`x = (target + sum) / 2`

此时问题就转化为，用`nums`装满容量为`x`的背包，有几种方法。

这里的`x`，就是`bagSize`，也就是我们后面要求的背包容量


1. `dp[i][j]`：使用 `下标为[0, i]`的`nums[i]`能够凑满`j`（包括j）这么大容量的包，有`dp[i][j]`种方法。
2. 过程，抽象化如下：
    - 不放物品i：即背包容量为j，里面不放物品i，装满有dp[i - 1][j]中方法。
    - 放物品i： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[i - 1][j - 物品i容量] 种方法。
    ```
    if (nums[i] > j) dp[i][j] = dp[i - 1][j]; 
    else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
    ```
3. 初始化
4. 确定遍历顺序
5. 模拟

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0;
        if ((target + sum) % 2 != 0) return 0;
        int bagsize = (target + sum) / 2;   // 转换为背包问题

        vector<vector<int>> dp(nums.size(), vector<int>(bagsize + 1, 0));   // 使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法

        // 初始化最上行
        if (nums[0] <= bagsize) dp[0][nums[0]] = 1;
        // 初始化最左列
        dp[0][0] = 1;
        int numZero = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) numZero++;
            dp[i][0] = (int) pow(2.0, numZero);
        }

        for (int i = 1; i < nums.size(); i++) {   // 行，遍历物品
            for (int j = 1; j <= bagsize; j++) {   // 列，遍历背包
                if (nums[i] > j) dp[i][j] = dp[i - 1][j];   // 背包容量装不下物品i，选择不放
                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];   // 不放的方案数+放的方案数
            }
        }
        return dp[nums.size() - 1][bagsize];
    }
};
```

## 一维数组（滚动数组）

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0;
        if ((target + sum) % 2 != 0) return 0;
        int bagsize = (target + sum) / 2;   // 转换为背包问题

        vector<int> dp(bagsize + 1, 0);   // 填满j（包括j）这么大容积的包，有dp[j]种方法
        // dp[j] += dp[j - nums[i]]

        // 初始化
        dp[0] = 1;

        for (int i = 0; i < nums.size(); i++) {   // 行，遍历物品
            for (int j = bagsize; j >= nums[i]; j--) {   // 列，遍历背包
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagsize];
    }
};

```
