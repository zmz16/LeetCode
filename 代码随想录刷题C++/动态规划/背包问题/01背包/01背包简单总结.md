# 总结

## 一、纯01背包

[纯 0 - 1 背包](K46携带研究材料.md)是求 **给定背包容量 装满背包 的最大价值是多少**。

1. 确定dp数组以及下标的含义
`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。

2. 确定递推公式
`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

3. dp数组如何初始化
```cpp
// 初始化 dp
vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));
for (int j = bagWeight; j >= weight[0]; j--) {
    dp[0][j] = dp[0][j - weight[0]] + value[0];
}
```

4. 确定遍历顺序
01背包二维dp数组在遍历顺序上，**外层遍历物品 ，内层遍历背包容量 和 外层遍历背包容量 ，内层遍历物品 都是可以的**！
但是先遍历物品更好理解。代码如下：
```cpp
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组里元素的变化
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

5. 举例推导dp数组

## 二、给定背包容量，能不能装满这个背包

[416. 分割等和子集](416分割等和子集.md)是求 给定背包容量，能不能装满这个背包。

## 三、给定背包容量，尽可能装，最多能装多少

[1049. 最后一块石头的重量 II ](1049最后一块石头的重量.md)是求 给定背包容量，尽可能装，最多能装多少

## 四、给定背包容量，装满背包有多少种方法

[494. 目标和](494目标和.md)是求 **给定背包容量，装满背包有多少种方法**

1. 确定dp数组以及下标的含义
dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法

2. 确定递推公式
`dp[j] += dp[j - nums[i]]`

    **注意：求装满背包有几种方法类似的题目，递推公式基本都是这样的。**

3. dp数组如何初始化
dp[0] 初始化为1 ，dp[j]其他下标对应的数值应该初始化为0。

4. 确定遍历顺序
01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。

5. 举例推导dp数组

## 给定背包容量，装满背包最多有多少个物品

[474. 一和零](474一和零.md)是求 给定背包容量，装满背包最多有多少个物品。

1. 确定dp数组（dp table）以及下标的含义
dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。

2. 确定递推公式
`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);`
字符串集合中的一个字符串0的数量为zeroNum，1的数量为oneNum。

3. dp数组如何初始化
因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖。

4. 确定遍历顺序
01背包一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！

5. 举例推导dp数组
