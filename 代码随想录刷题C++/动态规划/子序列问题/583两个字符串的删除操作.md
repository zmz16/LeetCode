# 题目链接

https://leetcode.cn/problems/delete-operation-for-two-strings/description/

## 动态规划一

确定递推公式
- 当`word1[i - 1] 与 word2[j - 1]`相同的时候
- 当`word1[i - 1] 与 word2[j - 1]`不相同的时候
当`word1[i - 1] 与 word2[j - 1]`相同的时候，`dp[i][j] = dp[i - 1][j - 1]`;

当`word1[i - 1] 与 word2[j - 1]`不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为`dp[i - 1][j] + 1`

情况二：删word2[j - 1]，最少操作次数为`dp[i][j - 1] + 1`

情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为`dp[i - 1][j - 1] + 2`

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：`dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});`

因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，所以递推公式可简化为：`dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);`

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        // 初始化
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        // 遍历
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

## 动态规划二

统计最长公共子序列，两个字符串大小相加减去`2 * 最长公共子序列`即为结果

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        int ans = 0;
        // 遍历
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
                ans = max(ans, dp[i][j]);
            }
        }
        return m + n - 2 * ans;
    }
};
```
