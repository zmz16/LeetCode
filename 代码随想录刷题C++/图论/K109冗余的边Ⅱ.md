# 题目链接

https://kamacoder.com/problempage.php?pid=1182

## C++

```cpp
#include <iostream>
#include <vector>

using namespace std;

int n;   // 节点数量
vector<int> father(1001, 0);   // 按照节点大小定义数组大小

// 并查集初始化
void init() {
	for (int i = 1; i <= n; i++) {
		father[i] = i;
	}
}

// 并查集里寻根的过程
int find(int u) {
	return u == father[u] ? u : father[u] = find(father[u]);
}

// 判断u和v是否找到同一个根
bool isSame(int u, int v) {
	u = find(u);
	v = find(v);
	return u == v;
}

// 将 v->u 这条边加入并查集
void join(int u, int v) {
	u = find(u);
	v = find(v);
	if (u == v) return;
	father[v] = u;
}

// 删一条边后判断是不是树
bool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {
	init();
	for (int i = 0; i < n; i++) {
		if (i == deleteEdge) {
			continue;
		}
		if (isSame(edges[i][0], edges[i][1])) {   // 构成有向环了，一定不是树
			return false;
		}
		join(edges[i][0], edges[i][1]);
	}
	return true;
}

// 在有向图里找到要删除的那条边，使其变成树
void getRemoveEdge(const vector<vector<int>>& edges) {
	init();
	for (int i = 0; i < n; i++) {
		if (isSame(edges[i][0], edges[i][1])) {
			cout << edges[i][0] << " " << edges[i][1];
			return;
		}
		else {
			join(edges[i][0], edges[i][1]);
		}
	}
}

int main() {
	int s, t;
	vector<vector<int>> edges;  // 记录每条边

	cin >> n;   // 节点，n边

	vector<int> inDegree(n + 1, 0);   // 记录节点的入度

	for (int i = 0; i < n; i++) {
		cin >> s >> t;
		inDegree[t]++;   // 统计入度
		edges.push_back({ s, t });   // 把每条边记录下来
	}

	vector<int> vec;   // 记录入度为2的边
	// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边
	for (int i = n - 1; i >= 0; i--) {
		if (inDegree[edges[i][1]] == 2) {
			vec.push_back(i);
		}
	}

	// 入度为2的边
	if (vec.size() > 0) {
		if (isTreeAfterRemoveEdge(edges, vec[0])) {
			cout << edges[vec[0]][0] << " " << edges[vec[0]][1];
		}
		else {
			cout << edges[vec[1]][0] << " " << edges[vec[1]][1];
		}
		return 0;
	}

	getRemoveEdge(edges);
}
```