# 题目链接

https://kamacoder.com/problempage.php?pid=1170

## 邻接矩阵解法

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

vector<vector<int>> result;
vector<int> path;   // 0节点到终点的路径

void dfs(const vector<vector<int>>& graph, int x, int n) {
	// x：目前遍历的节点
	// graph：存当前的图
	// n：终点
	if (x == n) {   // 当前遍历的节点到达终点，找到一条符合节点的路径
		result.push_back(path);
		return;
	}
	
	for (int i = 1; i <= n; i++) {
		if (graph[x][i] == 1) {   // 找到x指向的节点，就是节点i
			path.push_back(i);   // 节点i加入路径
			dfs(graph, i, n);   // 进入下一层递归
			path.pop_back();   // 回溯
		}
	}
}

int main() {
	int n, m;
	cin >> n >> m;   // 节点和边个数

	// 邻接矩阵
	vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));   // 邻接矩阵，节点编号为1-n，这样可以对应起来
	for (int i = 1; i <= m; i++) {
		int s, e;    // start, end
		cin >> s >> e;
		graph[s][e] = 1;
	}
	
    // 将节点1加入path，因为每一条路径都从1开始
	path.push_back(1);
	dfs(graph, 1, n);

	// 打印结果
    if (result.empty()) {
        cout << -1;
    }
	for (int i = 0; i < result.size(); i++) {
		for (int j = 0; j < result[i].size() - 1; j++) {
			cout << result[i][j] << " ";
		}
		cout << result[i][result[i].size() - 1] << endl;
	}
	return 0;
}
```

## 邻接表解法

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

vector<vector<int>> result;
vector<int> path;   // 0节点到终点的路径

void dfs(const vector<list<int>>& graph, int x, int n) {
	// x：目前遍历的节点
	// graph：存当前的图
	// n：终点
	if (x == n) {   // 当前遍历的节点到达终点，找到一条符合节点的路径
		result.push_back(path);
		return;
	}
	
	for (int i : graph[x]) {   // 找到x指向的节点
		path.push_back(i);   // 节点i加入路径
		dfs(graph, i, n);   // 进入下一层递归
		path.pop_back();   // 回溯
	}
}

int main() {
	int n, m;
	cin >> n >> m;   // 节点和边个数

	// 邻接表
	vector<list<int>> graph1(n + 1);    // 表示节点编号
	for (int i = 1; i <= m; i++) {
		int s, e;    // start, end
		cin >> s >> e;
		graph1[s].push_back(e);
	}
	
	path.push_back(1);
	dfs(graph1, 1, n);

	// 打印结果
	if (result.empty()) {
        cout << -1;
    }
	for (int i = 0; i < result.size(); i++) {
		for (int j = 0; j < result[i].size() - 1; j++) {
			cout << result[i][j] << " ";
		}
		cout << result[i][result[i].size() - 1] << endl;
	}
	return 0;
}
```
