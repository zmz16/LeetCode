# 题目链接

https://kamacoder.com/problempage.php?pid=1171

## C++

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

int dir[4][2] = { 0,1,1,0,0,-1,-1,0 };   // 代表四个方向
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
	for (int i = 0; i < 4; i++) {   // 搜索4个方向
		int next_x = x + dir[i][0];
		int next_y = y + dir[i][1];
		if (next_x < 0 || next_x >= grid.size() || next_y < 0 || next_y >= grid[0].size()) {
			// 位置不合法，继续下一个
			continue;
		}
		if (!visited[next_x][next_y] && grid[next_x][next_y] == 1) {   // 没被访问过并且是陆地
			visited[next_x][next_y] = true;
			bfs(grid, visited, next_x, next_y);
		}
	}
}

int main() {
	int n, m;   // 矩阵的行和列
	cin >> n >> m; 

	// 读取输入矩阵
	vector<vector<int>> grid(n, vector<int>(m));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> grid[i][j];
		}
	}

	// 记录是否遍历过
	vector<vector<bool>> visited(n, vector<bool>(m, false));

	int result = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (!visited[i][j] && grid[i][j] == 1) {
				visited[i][j] = true;
				result++;   // 遇到没访问过的陆地，+1
				dfs(grid, visited, i, j);   // 将与其链接的陆地都标记上 true
			}
		}
	}
	cout << result << endl;
	return 0;
}
```