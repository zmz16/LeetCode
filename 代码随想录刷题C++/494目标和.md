# 题目链接

https://leetcode.cn/problems/target-sum/description/

## 回溯算法

本题要如何使表达式结果为`target`，

既然为`target`，那么就一定有 `left组合 - right组合 = target`。

`left + right = sum`，而`sum`是固定的。`right = sum - left`

`left - (sum - left) = target` 推导出 `left = (target + sum)/2` 。

`target`是固定的，`sum`是固定的，`left`就可以求出来。

此时问题就是在集合`nums`中找出和为`left`的组合。

```cpp
class Solution {
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(vector<int>& nums, int new_target, int sum, int startIndex) {
        if (sum == new_target) {
            result.push_back(path);
        }

        for (int i = startIndex; i < nums.size() && sum <= new_target; i++) {
            sum += nums[i];
            path.push_back(nums[i]);
            backtracking(nums, new_target, sum, i + 1);
            path.pop_back();
            sum -= nums[i];
        }
    }

public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (target > sum) return 0;
        if ((target + sum) % 2 != 0) return 0;
        int new_target = (target + sum) / 2;   // 转变为组合总和问题

        path.clear();
        result.clear();
        sort(nums.begin(), nums.end());
        backtracking(nums, new_target, 0, 0);
        return result.size();
    }
};
```