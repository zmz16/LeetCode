# 题目链接

https://leetcode.cn/problems/implement-stack-using-queues/

## 用两个队列实现栈

使用`que2`作为辅助，备份出队的前`size-1`个元素

```C++

// 时间复杂度: pop为O(n)，top为O(n)，其他为O(1)
// 空间复杂度: O(n)

class MyStack {
public:
    queue<int> que1;
    queue<int> que2;   // 辅助队列，用于备份

    MyStack() {
        
    }
    
    void push(int x) {
        // 直接入队
        que1.push(x);
    }
    
    int pop() {
        int size = que1.size();
        size--;   // 将que1导入que2，但要保留最后一个元素，所以先给size减1
        while (size--) {
            que2.push(que1.front());
            que1.pop();
        }

        int result = que1.front();   // 留下的最后一个元素就是要返回的值
        que1.pop();
        que1 = que2;   // 将que2赋值给que1
        while (! que2.empty()) {   // 清空que2
            que2.pop();
        }

        return result;
    }
    
    int top() {
        int result = this->pop();
        que1.push(result);
        return result;
    }
    
    bool empty() {
        return que1.empty();
    }
};
```

## 用一个队列实现栈

**将弹出的元素再次写入队列，只保留最后一个元素，然后弹出**

```cpp
// 时间复杂度: pop为O(n)，top为O(n)，其他为O(1)
// 空间复杂度: O(n)

class MyStack {
public:
    queue<int> que;

    MyStack() {
        
    }
    
    void push(int x) {
        // 直接入队
        que.push(x);
    }
    
    int pop() {
        int size = que.size();
        size--;   // 将que1导入que2，但要保留最后一个元素，所以先给size减1
        while (size--) {
            que.push(que.front());
            que.pop();
        }

        int result = que.front();   // 留下的最后一个元素就是要返回的值
        que.pop();
        return result;
    }
    
    int top() {
        return que.back();
    }
    
    bool empty() {
        return que.empty();
    }
};
```