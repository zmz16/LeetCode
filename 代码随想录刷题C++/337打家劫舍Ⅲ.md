# 题目链接

https://leetcode.cn/problems/house-robber-iii/description/

## 暴力递归（超时）

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        if (root->left == nullptr && root->right == nullptr) {   // 只有一个节点
            return root->val;
        }

        // 偷父节点
        int val1 = root->val;   // 选择了父节点，那么他的左右孩子就不能选择了
        if (root->left) {
            val1 += rob(root->left->left) + rob(root->left->right);
        }
        if (root->right) {
            val1 += rob(root->right->left) + rob(root->right->right);
        }

        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right);   // 考虑父节点的左右孩子

        return max(val1, val2);
    }
};
```

## 记忆化递归

```cpp
class Solution {
public:
    unordered_map<TreeNode*, int> umap;   // 记录计算过的结果
    int rob(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        if (root->left == nullptr && root->right == nullptr) {   // 只有一个节点
            return root->val;
        }
        if (umap[root]) {
            return umap[root];
        }

        // 偷父节点
        int val1 = root->val;   // 选择了父节点，那么他的左右孩子就不能选择了
        if (root->left) {
            val1 += rob(root->left->left) + rob(root->left->right);
        }
        if (root->right) {
            val1 += rob(root->right->left) + rob(root->right->right);
        }

        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right);   // 考虑父节点的左右孩子

        umap[root] = max(val1, val2);
        return max(val1, val2);
    }
};
```

## 动态规划

```cpp
class Solution {
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == nullptr) {
            return vector<int>{0, 0};
        }
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
};
```
