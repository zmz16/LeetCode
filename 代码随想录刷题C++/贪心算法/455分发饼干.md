# 题目链接

https://leetcode.cn/problems/assign-cookies/description/

## 大饼干喂给大胃口

```cpp
// 自己写的
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int s_index = s.size() - 1;   // 饼干数组的下标
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) {   // 遍历胃口
            if (s_index < 0) {   // 饼干数组是否结束
                break;
            }
            if (s[s_index] >= g[i]) {
                result++;
                s_index--;
            }
        }
        return result;
    }
};

// 代码优化
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int s_index = s.size() - 1;   // 饼干数组的下标
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) {   // 遍历胃口
            if (s_index >= 0 && s[s_index] >= g[i]) {   // 遍历饼干
                result++;
                s_index--;
            }
        }
        return result;
    }
};
```

## 小饼干喂给小胃口

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int g_index = 0;   // 胃口数组的下标
        int result = 0;
        for (int i = 0; i < s.size(); i++) {   // 遍历饼干
            if (g_index < g.size() && g[g_index] <= s[i]) {   // 遍历饼干
                g_index++;
            }
        }
        return g_index;
    }
};
```