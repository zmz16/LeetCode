# 题目链接

https://leetcode.cn/problems/palindrome-partitioning/description/

## C++

```cpp
class Solution {
private:
    vector<string> path; // 放满足回文的子串
    vector<vector<string>> res;

    // 判断字符是否回文
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }

    // 回溯算法
    void backtracking(const string& s, int startIndex) {
        if (startIndex >= s.size()) {
            res.push_back(path);
            return;
        }

        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {
                continue;
            }
            backtracking(s, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<string>> partition(string s) {
        res.clear();
        path.clear();
        backtracking(s, 0);
        return res;
    }
};
```

## 优化回文的计算

上述代码`isPalindrome`函数运用双指针的方法来判定对于一个字符串s, 给定起始下标和终止下标, 截取出的子字符串是否是回文字串。但是其中有一定的重复计算存在：

例如给定字符串`"abcde"`, 在已知`"bcd"`不是回文字串时, 不再需要去双指针操作`"abcde"`而可以直接判定它一定不是回文字串。

```cpp
class Solution {
private:
    vector<string> path; // 放满足回文的子串
    vector<vector<string>> res;
    vector<vector<bool>> isPalindrome;

    void computePalindrome(const string & s) {
        // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串
        isPalindrome.resize(s.size(), vector<bool>(s.size(), false));   // 根据字符串s, 刷新布尔矩阵的大小
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (j == i) {   // 单字符情况
                    isPalindrome[i][j] = true;
                }
                else if (j - i == 1) {   // 双字符情况
                    isPalindrome[i][j] = (s[i] == s[j]);
                }
                else {   // 多字符情况，只要两边的字符相同并且中间的字符也是回文，那么该字符就是回文
                    isPalindrome[i][j] = (s[i] == s[j] && isPalindrome[i + 1][j - 1]);
                }
            }
        }
    }

    // 回溯算法
    void backtracking(const string& s, int startIndex) {
        if (startIndex >= s.size()) {
            res.push_back(path);
            return;
        }

        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome[startIndex][i]) {
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {
                continue;
            }
            backtracking(s, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<string>> partition(string s) {
        res.clear();
        path.clear();
        computePalindrome(s);
        backtracking(s, 0);
        return res;
    }
};
```